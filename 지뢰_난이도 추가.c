#include<stdio.h>
#include<windows.h>
#include<time.h>
#define _CRT_SECURE_NO_WARNINGS

int arr[22][22] = { 0 }; //지뢰의 위치와 근처 지뢰의 개수를 담고있는 배열
int screen[22][22] = { {100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100},{100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100}
,{100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100} ,{100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100}
,{100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100} ,{100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100}
,{100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100} ,{100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100}
,{100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100} ,{100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100}
,{100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100} ,{100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100}
,{100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100} ,{100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100}
,{100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100} ,{100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100}
,{100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100} ,{100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100}
,{100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100} ,{100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100}
,{100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100} ,{100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100} };
//arr배열을 가려주는 역할을 하는 배열 (100은 아무 의미 없는숫자. 0~9, 11을 제외한 수라면 뭐든 괜찮지만 가장 보기 편한?수가 100이라고 생각해서 100으로 설정)

int i; // 반복문의 재료
int j; // 반복문의 재료
int cnt = 0; // 근처 지뢰의 개수를 셀때 쓰는 변수
int rank;

int guess_bomb = 0;

int whenstart; // 시작한 시간을 가지고있는 변수
int whenend;   // 끝난 시간을 가지고있는 변수
 // 끝난 시간 - 시작한 시간 = 게임을 플레이하는데 걸린 시간

int x = 0; // 콘솔창 안의 커서(캐롯?)의 좌표를 가지고있는 변수
int y = 0; // 콘솔창 안의 커서(캐롯?)의 좌표를 가지고있는 변수

int difficulty; // 난이도조절에 쓰는 변수
int size; // 지뢰찾기 판의 크기를 조절하는 변수
int bomb; // 지뢰의 개수를 조절하는 변수

void key_move(); // 키보드 입력을 받는 함수
void gotoxy(int x, int y); // 콘솔창에서 커서(캐롯)의 위치를 옮겨주는 함수

void select_difficulty(); // 난이도 고르는 함수
void menu(); // 시작할때 나오는 메인메뉴
void bombmade(); // 지뢰판에서 폭탄의 위치와 주변 폭탄의 개수에 따른 그 칸의숫자를 정해주는 함수 
void minepan(); // 우리 눈에 보이는 지뢰판 screen배열을 출력해주는 함수
void pung(); // 폭탄을 골랐을때 들어가는 함수
void restart(); // 게임이 끝난 후 재시작을 골랐을때 적용되는 함수
void zero(); // 0 블럭들 (1칸 간격에 폭탄이 하나도 없는 블럭)을 골랐을때 붙어있는 다른 0블럭, 지뢰를 제외한 블럭들을 같이 까는 함수
void win(); // 게임을 클리어했을때 실행되는 함수
void end(); // 게임을 클리어했는지 판별하는 함수
void insert_rank(); // 랭크 추가해주는 함수

// void compare_rank(); //랭크 순위 매겨주는 함수 

int main() //메인 함수
{
	srand(time(NULL)); // 폭탄의 위치를 결정할때 srand함수를 씀

	menu(); // 처음 시작할때 메인화면 출력
	bombmade(); // 지뢰판에서 폭탄의 위치와 주변 폭탄의 개수에 따른 그 칸의숫자를 정해주는 함수  

	while (1)
	{

		minepan();		 // 우리 눈에 보이는 지뢰판 screen배열을 출력해주는 함수
		end();			 // 게임을 클리어했는지 판별하는 함수

		if (screen[y][x / 2] == 9) // 폭탄을 골랐는지 판별하는 코드
		{
			pung();
		}

		key_move();//키보드 입력을 받아 조작하는 함수
	}
}
void key_move() //키보드 입력을 받는 함수
{
	int chr; // 키보드 입력을 받아줌
	gotoxy(x, y); // 콘솔에서 커서 위치 바꾸는 함수
	while (1) {
	rescan:
		chr = getch(); // chr 이 가장 최근에 눌린 키보드의 아스키코드를 잡고있음

		if (chr == 102) // f키 (지뢰 표시)
		{
			if (screen[y][x / 2] == 100)		 //screen배열은 100일때 특수문자 '■'를 출력함 (아직 까보지 않은 칸) 
				screen[y][x / 2] = 11;			 //  '■'(아직 까지 않은 칸) 을 '폭'(폭탄 표시)로 바꿔줌 =>이미 깐 칸은 '폭'표시를 할수없음
			else if (screen[y][x / 2] == 11)	 //screen배열은 11일때 '폭'(폭탄이라는 표시)를 출력함
				screen[y][x / 2] = 100;			 // '폭'(폭탄이라는 표시)를 '■'(아직 까보지 않은 칸)으로 바꿔줌

			system("cls");  // 변경사항을 패치?하기위해 화면을 지우고, 판을 새로출력함
			minepan();		// 변경사항을 패치?하기위해 화면을 지우고, 판을 새로출력함
			gotoxy(x, y);
		}
		else if (kbhit()) // ←↑→↓ 는 키보드를 누르면 2개의 신호가 입력되기때문에 첫번째 입력 신호를 씹어주기위함.
		{ 
			gotoxy(x, y); // 저장해둔 좌표로 콘솔창내부의 커서위치를 이동시킴
			chr = getch();  //  ←↑→↓ 는 키보드를 누를때와 땔때 2번 신호가 입력되는데 첫번째 신호는 모두 같고 2번째 신호로 화살표의 방향을 판별함. 그래서 2번째 신호를 잡아주는 역할을 함.

			if (chr == 72) {			//↑ 상
				y--;			// 커서(캐롯)의 좌표를 변경
				if (y < 0) y = 0;						// 커서가 지뢰찾기 판을 벗어나는걸 방지하기 위한 코드
			}

			else if (chr == 80) {		//↓ 하
				y++;			// 커서(캐롯)의 좌표를 변경
				if (y > size - 1) y = size - 1;				//커서가 지뢰찾기 판을 벗어나는걸 방지하기 위한 코드
			}

			else if (chr == 75) {		//← 좌
				x = x - 2;		// 커서(캐롯)의 좌표를 변경
				if (x < 0) x = 0;						//커서가 지뢰찾기 판을 벗어나는걸 방지하기 위한 코드
			}

			else if (chr == 77) {		//→ 우
				x = x + 2;		// 커서(캐롯)의 좌표를 변경
				if (x > (size * 2) - 1) x = (size - 1) * 2;		//커서가 지뢰찾기 판을 벗어나는걸 방지하기 위한 코드
			}

			gotoxy(x, y);		// 콘솔에서 커서 위치 바꾸는 함수
		}
		else		 // ←↑→↓, f 외의 모든 키로 블럭을 깔수 있게 해주는 코드
		{
			screen[y][x / 2] = arr[y][x / 2];
			break;
		}
	}
}
void gotoxy(int x, int y) { // 저장해둔 커서(캐롯)의 좌표를 가져옴
	COORD Pos = { x, y }; // 좌표값을 저장하는 구조체
	SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), Pos); // 콘솔에서 Pos에 저장된 좌표로 위치 바꾸기
}
void select_difficulty()
{
	printf("난이도를 고르세요.\n 1:easy \t  (7X7, 10 bombs) \n\n 2:medium \t  (16X16, 40 bombs) \n\n 3:hard \t  (22X22, 99bombs) \n\n 7:test yout luck (7X7, 48 bombs) \n>");
	//난이도 조절을 위한 메뉴판?을 출력해주는 출력문
	scanf("%d", &difficulty); // 선택한 난이도를 입력받는 코드
	
	if (difficulty == 1)		//쉬움
	{
		size = 9;	 // 지뢰판의 크기: 9X9
		bomb = 10;   // 폭탄의 개수: 10개
	}
	else if (difficulty == 2)	//중간
	{
		size = 16;	// 지뢰판의 크기: 16X16
		bomb = 40;	// 폭탄의 개수: 40개
	}
	else if (difficulty == 3)	//어려움
	{
		size = 22;	// 지뢰판의 크기: 22X22
		bomb = 99;	// 폭탄의 개수: 99개
	}
	else if (difficulty == 7)	// 1개의 블럭 외에 모두 폭탄인 난이도
	{
		size = 7;	// 지뢰판의 크기: 7X7
		bomb = 48;	// 폭탄의 개수: 48개
	}
	else // 1,2,3,7외의 수를 (잘못) 입력했을때 화면을 지우고 다시 메뉴판을 출력함.
	{
		system("cls");
		menu();
	}
}
void menu()
{
	printf("|─────────────────────────────────────────────────────────────────── \n| \n| \n"); // 그냥 한번 만들어본 문구...?
	printf("|                           ★지뢰찾기★                           \n");
	printf("|                    ← ↑ → ↓로 조작, f로 폭탄표시                 \n| \n| \n");
	printf("|─────────────────────────────────────────────────────────────────── \n");
	select_difficulty(); // 난이도 선택하는 함수

	//menu_scan: 난이도 조절이 없었을때 아무키나 누르면 시작하게 만들어놓은 함수
	//	if (kbhit())
	//		return 0;
	//	else
	//		goto menu_scan;
	//
}
void bombmade()
{
	int a, b; // 지뢰의 좌표를 설정하기 위해 랜덤으로 하나의 수를 잡아주는 변수들
	for (i = 0; i < bomb;) // 폭탄의 개수만큼 반복문을 돌림
	{
	rand: //rand함수가 정해준 좌표가 중복돼었을때 돌아오기 위한 goto문

		a = (rand() % size); // rand변수를쓰면 자꾸 변하기때문에 a,b를 선언하여 저장해줌)
		b = (rand() % size); // rand변수를쓰면 자꾸 변하기때문에 a,b를 선언하여 저장해줌)

		/*if (a == 0 && b == 0) //  arr[0][0] 즉 커서가 시작하는 칸이 지뢰이면 바로 게임이 끝나버리는 버그가 있었기에 만들었던 코드
			goto rand;*/

		if (arr[a][b] == 0) //랜덤으로 잡은 배열의 한 좌표가 지뢰가 아닐때 그곳을 지뢰로 설정함.
		{
			arr[a][b] = 9;
			i++;			//설정한 지뢰의 개수를 세기 위해 지뢰를 설치할때만 i가 늘어남.
		}
		else
			goto rand;		////랜덤으로 잡은 배열의 한 좌표가 지뢰일때, 중복되면 안되기때문에 돌아가서 다시 rand로 한 좌표를 받음
	}

	for (i = 0; i < size; i++)	   // 0 ~ (size -1) = 배열의 좌표  
	{
		for (j = 0; j < size; j++) // 0 ~ (size -1) = 배열의 좌표 
		{
			cnt = 0; // 주변의 폭탄 개수를 세주는 변수

			if (arr[i][j] == 9) //선택한 칸이 폭탄(9)라면 할 필요가 없으니 넘어감
				continue;
			else if (arr[i][j] < 9) // 선택한 칸이 폭탄이 아닐때만 작동함
			{

				if (i == 0 && j == 0) //왼쪽 위 모서리
				{
					if (arr[i][j + 1] == 9)			// 오른쪽
						cnt++;
					if (arr[i + 1][j + 1] == 9)		// 오른쪽 아래
						cnt++;
					if (arr[i + 1][j] == 9)			// 아래
						cnt++;
				}
				else if (i == 0 && j != 0 && j != size - 1)// 윗줄
				{
					if (arr[i][j - 1] == 9)			// 왼쪽
						cnt++;
					if (arr[i + 1][j - 1] == 9)		// 왼쪽 아래
						cnt++;
					if (arr[i + 1][j] == 9)			// 아래
						cnt++;
					if (arr[i + 1][j + 1] == 9)		// 오른쪽 아래
						cnt++;
					if (arr[i][j + 1] == 9)			// 오른쪽
						cnt++;

				}
				else if (i == 0 && j == size - 1) // 오른쪽 위 모서리
				{
					if (arr[i][j - 1] == 9)			// 왼쪽
						cnt++;
					if (arr[i + 1][j - 1] == 9)		// 왼쪽 아래
						cnt++;
					if (arr[i + 1][j] == 9)			// 아래
						cnt++;
				}
				else if (i != 0 && i != size - 1 && j == 0) //왼쪽 모서리
				{
					if (arr[i - 1][j] == 9)			// 위
						cnt++;
					if (arr[i - 1][j + 1] == 9)		// 오른쪽 위
						cnt++;
					if (arr[i][j + 1] == 9)			// 오른쪽
						cnt++;
					if (arr[i + 1][j + 1] == 9)		// 오른쪽 아래
						cnt++;
					if (arr[i + 1][j] == 9)			// 아래
						cnt++;
				}
				else if (i != 0 && i != size - 1 && j == size - 1) // 오른쪽 모서리
				{
					if (arr[i - 1][j] == 9)			// 위
						cnt++;
					if (arr[i - 1][j - 1] == 9)		// 왼쪽 위
						cnt++;
					if (arr[i][j - 1] == 9)			// 왼쪽
						cnt++;
					if (arr[i + 1][j - 1] == 9)		// 왼쪽 아래
						cnt++;
					if (arr[i + 1][j] == 9)			// 아래
						cnt++;
				}
				else if (i == size - 1 && j == 0) // 왼쪽 아래 모서리
				{
					if (arr[i - 1][j] == 9)			// 위
						cnt++;
					if (arr[i - 1][j + 1] == 9)		// 오른쪽 위
						cnt++;
					if (arr[i][j + 1] == 9)			// 오른쪽
						cnt++;
				}
				else if (i == size - 1 && j != 0 && j != size - 1) // 밑줄
				{
					if (arr[i][j - 1] == 9)			// 왼쪽
						cnt++;
					if (arr[i - 1][j - 1] == 9)		// 왼쪽 위
						cnt++;
					if (arr[i - 1][j] == 9)			// 위
						cnt++;
					if (arr[i - 1][j + 1] == 9)		// 오른쪽 위
						cnt++;
					if (arr[i][j + 1] == 9)			// 오른쪽
						cnt++;
				}
				else if (i == size - 1 && j == size - 1) // 오른쪽 아래 모서리
				{
					if (arr[i][j - 1] == 9)			// 왼쪽
						cnt++;
					if (arr[i - 1][j - 1] == 9)		// 왼쪽 위
						cnt++;
					if (arr[i - 1][j] == 9)			// 위
						cnt++;
				}
				else  // 가운데부분
				{
					if (arr[i - 1][j - 1] == 9)		// 왼쪽 위
						cnt++;
					if (arr[i - 1][j] == 9)			// 위
						cnt++;
					if (arr[i - 1][j + 1] == 9)		// 오른쪽 위
						cnt++;
					if (arr[i][j - 1] == 9)			// 왼쪽
						cnt++;
					if (arr[i][j + 1] == 9)			// 오른쪽
						cnt++;
					if (arr[i + 1][j + 1] == 9)		// 오른쪽 아래
						cnt++;
					if (arr[i + 1][j] == 9)			// 아래
						cnt++;
					if (arr[i + 1][j - 1] == 9)		// 왼쪽 아래
						cnt++;
				}
			}
			arr[i][j] = cnt; // 선택한 칸을 중심으로 3X3(상하좌우,대각선 1칸길이)에 있는 폭탄의 개수를 세서 칸에 숫자로 넣어줌
		}
	}
	whenstart = clock();
}
void minepan()
{
	zero(); // 0 블럭들 (1칸 간격에 폭탄이 하나도 없는 블럭)을 골랐을때 붙어있는 다른 0블럭, 지뢰를 제외한 블럭들을 같이 까는 함수
	system("cls"); // 화면에 출력된 내용들을 지우는 명령어
	for (i = 0; i < size; i++) //0 ~ (size-1) = 배열의 좌표
	{
		for (j = 0; j < size; j++)//0 ~ (size-1) = 배열의 좌표
		{
			if (screen[i][j] == 100) // 기본설정(아직 까지않은 칸)
				printf("■");
			else if (screen[i][j] == 0)		//선택한 칸을 중심으로 3X3(상하좌우, 대각선 1칸길이)에 폭탄이 없음 
				printf("○");
			else if (screen[i][j] == 1)		//선택한 칸을 중심으로 3X3(상하좌우, 대각선 1칸길이)에 있는 폭탄의 개수가 1개일때
				printf("①");
			else if (screen[i][j] == 2)
				printf("②");
			else if (screen[i][j] == 3)
				printf("③");
			else if (screen[i][j] == 4)
				printf("④");
			else if (screen[i][j] == 5)		//선택한 칸을 중심으로 3X3(상하좌우, 대각선 1칸길이)에 있는 폭탄의 개수가 5개일때
				printf("⑤");
			else if (screen[i][j] == 6)
				printf("⑥");
			else if (screen[i][j] == 7)
				printf("⑦");
			else if (screen[i][j] == 8)		//선택한 칸을 중심으로 3X3(상하좌우, 대각선 1칸길이)에 있는 폭탄의 개수가 8개일때
				printf("⑧");
			else if (screen[i][j] == 9)		//선택한 칸이 폭탄일때
				printf("★");
			else if (screen[i][j] == 11)	//'폭'(폭탄이 있다는표시)를 한 칸
				printf("폭");
		}printf("\n");
	}


	guess_bomb = 0;
	for (i = 0; i < size; i++)
	{
		for (j = 0; j < size; j++)
			if (screen[i][j] == 11)
				guess_bomb++;
	}
	printf("\n\n\n \t\t\t\t 남은 지뢰(추정) = %d개\n", bomb - guess_bomb);
	

	for (i = 0; i < size; i++)  //테스트를 위해 만들어놓은 관리자용 코드(arr배열을 숫자의 형태(원형의 형태)로 지뢰판 밑에 출력해줌)
	{
		for (j = 0; j < size; j++)
		{
			printf("%d", arr[i][j]);
		}printf("\n");
	}
}
void pung()
{
	int end; // 게임을 재시작할건지, 끝낼건지를 받는 변수
	whenend = clock();
	system("cls");
	for (i = 0; i < size; i++)		// 0 ~(size-1) = 배열의 좌표
	{
		for (j = 0; j < size; j++)	// 0 ~(size-1) = 배열의 좌표
		{
			if (arr[i][j] == 0)	  //선택한 칸을 중심으로 3X3(상하좌우, 대각선 1칸길이)에 폭탄이 하나도 없을때
				printf("○");
			else if (arr[i][j] == 1)  //선택한 칸을 중심으로 3X3(상하좌우, 대각선 1칸길이)에 있는 폭탄의 개수가 1개일때
				printf("①");
			else if (arr[i][j] == 2)
				printf("②");
			else if (arr[i][j] == 3)
				printf("③");
			else if (arr[i][j] == 4)
				printf("④");
			else if (arr[i][j] == 5)
				printf("⑤");
			else if (arr[i][j] == 6)
				printf("⑥");
			else if (arr[i][j] == 7)
				printf("⑦");
			else if (arr[i][j] == 8)  //선택한 칸을 중심으로 3X3(상하좌우, 대각선 1칸길이)에 있는 폭탄의 개수가 8개일때
				printf("⑧");
			else if (arr[i][j] == 9)  //선택한 칸이 폭탄일때
				printf("★");
		}printf("\n");
	}

	printf("GAME OVER!!! \n 걸린시간 : %.2f초 \n\n게임을 재시작 하시려면 1번\n게임을 끝내시려면 0번을 눌러주세요.\n>", ((double)whenend - (double)whenstart) / 1000); // 게임이 몇초동안 진행됐는지 알려줌

rescan: // 0,1중 하나를 입력하지않았을때 다시 입력받기위해 돌아옴
	scanf("%d", &end); // 게임을 재시작할건지, 끝낼건지를 받음
	if (end == 0)
		exit(1); // 프로그램을 종료함
	else if (end == 1)
		restart();  // 프로그램의 처음으로 되돌아가 지뢰찾기를 다시 시작하게하는 함수
	else // 잘못 입력했을때
	{
		printf("\n\n\n잘못입력하셨습니다.\n1:게임 재시작\n0:게임 끝내기\n>");
		goto rescan;
	}
}
void restart()
{
	system("cls"); //화면 지우기
	menu(); // 메인메뉴 출력
	x = 0; //콘솔창 내 커서의 x좌표를 0으로 재설정함
	y = 0; //콘솔창 내 커서의 y좌표를 0으로 재설정함

	for (i = 0; i < size; i++) // 0 ~ (size-1) = 배열의 좌표
	{
		for (j = 0; j < size; j++) // 0 ~ (size-1) = 배열의 좌표
		{
			screen[i][j] = 100; //screen배열을 초기 상태로 초기화함
			arr[i][j] = 0;		//arr배열을 초기 상태로 초기화함
		}
	}
	bombmade();//초기화된 arr배열에 다시 폭탄의 위치 설정, 주변 폭탄의 개수에 따른 숫자를 집어넣음
	minepan(); //초기화된 screen배열('■'으로만 이루어진 상태)을 출력함
}
void zero()
{
	if (screen[y][x / 2] == 0) // 선택한 칸이 0을 가지고있을때(주변에 폭탄이 없을때) 붙어있는 칸들도 조건이 맞다면 출력해줌
	{
		for (int k = 0; k < 20; k++) // 20은 의미없는 숫자. 한번에 주변 1칸씩밖에 안벗겨지기때문에 여러번 반복해줌
		{
			for (i = 0; i < size; i++) // 0~(size-1) = 배열의 좌표
			{
				for (j = 0; j < size; j++) // 0~(size-1) = 배열의 좌표
				{


					cnt = 0;//주변 폭탄의 개수를 담고있는 변수
					if (screen[i][j] == 0)
					{
						if (arr[i - 1][j] != 9 || arr[i + 1][j] != 9 || arr[i][j + 1] != 9 || arr[i][j - 1] != 9)
						{
							if (arr[i - 1][j] != 9)
							{
								if (i == 0)//i가 0이라면 i-1은 배열의 범위를 넘어가기때문에 오류가 발생할수있음
									screen[i][j] = arr[i][j];
								else
									screen[i - 1][j] = arr[i - 1][j];
								cnt++;
							}

							if (arr[i + 1][j] != 9)
							{
								if (i == size - 1)//i가 size-1(좌표의 끝) 이라면 (size-1) +1은 배열의 범위를 넘어가기때문에 오류가 발생할수있음
									screen[i][j] = arr[i][j];
								else
									screen[i + 1][j] = arr[i + 1][j];
								cnt++;
							}

							if (arr[i][j - 1] != 9)
							{
								if (j == 0)//j가 0이라면 j-1은 배열의 범위를 넘어가기때문에 오류가 발생할수있음
									screen[i][j] = arr[i][j];
								else
									screen[i][j - 1] = arr[i][j - 1];
								cnt++;
							}

							if (arr[i][j + 1] != 9)
							{
								if (j == size - 1)//j가 size-1(좌표의 끝) 이라면 (size-1) +1은 배열의 범위를 넘어가기때문에 오류가 발생할수있음
									arr[i][j] = arr[i][j];
								else
									screen[i][j + 1] = arr[i][j + 1];
								cnt++;
							}
						}

						// 이 아래부턴 선택한 칸이 0일때 대각선 칸에 들어있는 수가 0,9가 아니라면 같이 까주는 명령어인데 검사의 범위가 배열의 범위를 벗어나지 않게 조건문으로 조절해줌
						// 이 아래부턴 선택한 칸이 0일때 대각선 칸에 들어있는 수가 0,9가 아니라면 같이 까주는 명령어인데 검사의 범위가 배열의 범위를 벗어나지 않게 조건문으로 조절해줌
						// 이 아래부턴 선택한 칸이 0일때 대각선 칸에 들어있는 수가 0,9가 아니라면 같이 까주는 명령어인데 검사의 범위가 배열의 범위를 벗어나지 않게 조건문으로 조절해줌

						if (i == 0 && j == 0) //왼쪽 위 모서리
						{
							if (arr[i + 1][j + 1] != 0 && arr[i + 1][j + 1] != 9)		// 오른쪽 아래
								screen[i + 1][j + 1] = arr[i + 1][j + 1];

						}
						else if (i == 0 && j != 0 && j != size - 1)// 윗줄					
						{

							if (arr[i + 1][j - 1] != 9 && arr[i + 1][j - 1] != 0)		// 왼쪽 아래
								screen[i + 1][j - 1] = arr[i + 1][j - 1];

							if (arr[i + 1][j + 1] != 9 && arr[i + 1][j + 1] != 0)		// 오른쪽 아래
								screen[i + 1][j + 1] = arr[i + 1][j + 1];

						}
						else if (i == 0 && j == size - 1) // 오른쪽 위 모서리						
						{
							if (arr[i + 1][j - 1] != 9 && arr[i + 1][j - 1] != 0)		// 왼쪽 아래
								screen[i + 1][j - 1] = arr[i + 1][j - 1];
						}
						else if (i != 0 && i != size - 1 && j == 0) //왼쪽 모서리				
						{
							if (arr[i - 1][j + 1] != 9 && arr[i - 1][j + 1] != 0)		// 오른쪽 위
								screen[i - 1][j + 1] = arr[i - 1][j + 1];

							if (arr[i + 1][j + 1] != 9 && arr[i + 1][j + 1] != 0)		// 오른쪽 아래
								screen[i + 1][j + 1] = arr[i + 1][j + 1];
						}
						else if (i != 0 && i != size - 1 && j == size - 1) // 오른쪽 모서리		
						{

							if (arr[i - 1][j - 1] != 9 && arr[i - 1][j - 1] != 0)		// 왼쪽 위
								screen[i - 1][j - 1] = arr[i - 1][j - 1];

							if (arr[i + 1][j - 1] != 9 && arr[i + 1][j - 1] != 0)		// 왼쪽 아래
								screen[i + 1][j - 1] = arr[i + 1][j - 1];
						}
						else if (i == size - 1 && j == 0) // 왼쪽 아래 모서리
						{
							if (arr[i - 1][j + 1] != 9 && arr[i - 1][j + 1] != 0)		// 오른쪽 위
								screen[i - 1][j + 1] = arr[i - 1][j + 1];

						}
						else if (i == size - 1 && j != 0 && j != size - 1) // 밑줄
						{

							if (arr[i - 1][j - 1] != 9 && arr[i - 1][j - 1] != 0)		// 왼쪽 위
								screen[i - 1][j - 1] = arr[i - 1][j - 1];

							if (arr[i - 1][j + 1] != 9 && arr[i - 1][j + 1] != 0)		// 오른쪽 위
								screen[i - 1][j + 1] = arr[i - 1][j + 1];

						}
						else if (i == size - 1 && j == size - 1) // 오른쪽 아래 모서리
						{

							if (arr[i - 1][j - 1] != 9 && arr[i - 1][j - 1] != 0)		// 왼쪽 위
								screen[i - 1][j - 1] = arr[i - 1][j - 1];
						}
						else  // 가운데부분
						{
							if (arr[i - 1][j - 1] != 9 && arr[i - 1][j - 1] != 0)		// 왼쪽 위
								screen[i - 1][j - 1] = arr[i - 1][j - 1];

							if (arr[i - 1][j + 1] != 9 && arr[i - 1][j + 1] != 0)		// 오른쪽 위
								screen[i - 1][j + 1] = arr[i - 1][j + 1];

							if (arr[i + 1][j + 1] != 9 && arr[i + 1][j + 1] != 0)		// 오른쪽 아래
								screen[i + 1][j + 1] = arr[i + 1][j + 1];

							if (arr[i + 1][j - 1] != 9 && arr[i + 1][j - 1] != 0)		// 왼쪽 아래
								screen[i + 1][j - 1] = arr[i + 1][j - 1];
						}

						// 이 위까진 선택한 칸이 0일때, 대각선의 칸이 0이나 9가 아니면 같이 까주는 코드인데 if문의 범위가 배열의 범위를 벗어나지 않게 조건문으로 조절해줌
						// 이 위까진 선택한 칸이 0일때, 대각선의 칸이 0이나 9가 아니면 같이 까주는 코드인데 if문의 범위가 배열의 범위를 벗어나지 않게 조건문으로 조절해줌
						// 이 위까진 선택한 칸이 0일때, 대각선의 칸이 0이나 9가 아니면 같이 까주는 코드인데 if문의 범위가 배열의 범위를 벗어나지 않게 조건문으로 조절해줌
					}
				}
			}
		}
	}

}
void win()
{
	int end; // 게임이 끝난 후, 게임을 재시작 할것인지, 게임을 끝낼건지에 대한 여부를 입력받는 변수
	system("cls"); // 화면 지우기

	for (i = 0; i < size; i++) // 0 ~ (size-1) = 배열의 좌표 범위   // 게임을 클리어했을때 지뢰찾기 판을 모두 보여주며 끝냄
	{
		for (j = 0; j < size; j++)// 0 ~ (size-1) = 배열의 좌표 범위
		{
			if (arr[i][j] == 0) //주변 칸의 폭탄의 개수
				printf("○");
			else if (arr[i][j] == 1)//주변 칸의 폭탄의 개수
				printf("①"); 
			else if (arr[i][j] == 2)//주변 칸의 폭탄의 개수
				printf("②");
			else if (arr[i][j] == 3)//주변 칸의 폭탄의 개수
				printf("③");
			else if (arr[i][j] == 4)//주변 칸의 폭탄의 개수
				printf("④");
			else if (arr[i][j] == 5)//주변 칸의 폭탄의 개수
				printf("⑤");
			else if (arr[i][j] == 6)//주변 칸의 폭탄의 개수
				printf("⑥");
			else if (arr[i][j] == 7)//주변 칸의 폭탄의 개수
				printf("⑦");
			else if (arr[i][j] == 8)//주변 칸의 폭탄의 개수
				printf("⑧");
			else if (arr[i][j] == 9)//선택한 칸이 폭탄일때
				printf("★");
		}printf("\n");
	}
	printf("축하드립니다!! 게임을 클리어하셨습니다!!\n"); // 게임 클리어시 뜨는 문구
	insert_rank();
	printf("걸린 시간: %.2f초", ((double)whenend - (double)whenstart) / 1000); // 게임 클리어에 몇초 걸렸는지 알려줌
	printf("\n\n게임을 재시작 하시려면 1번\n게임을 끝내시려면 0번을 눌러주세요.\n>"); // 게임 재시작/끄기 여부 묻기
rescan: // 잘못 입력받았을때 다시 돌아오기위해 만듬
	scanf("%d", &end); // 게임 재시작/끄기 여부 묻기
	if (end == 0)
		exit(1); // 게임 끄기
	else if (end == 1)
		restart(); // 게임 재시작

	else // 잘못 입력받았을때
	{
		printf("\n\n\n잘못입력하셨습니다.\n1:게임 재시작\n0:게임 끝내기\n>");
		goto rescan;
	}
}
void end()
{
	int find_bomb = 0; // 제대로 찾은 폭탄의 개수를 세어주는 변수
	int miss_bomb = 0;
	int crt = 0;
	guess_bomb = 0;

	for (i = 0; i < size; i++) // 0~ (size-1) == 배열의 좌표 범위
	{
		for (j = 0; j < size; j++) // 0~ (size-1) == 배열의 좌표 범위
		{
			if (screen[i][j] == 100 || screen[i][j] == 11)
				crt++;
			if (screen[i][j] == 11 && arr[i][j] == 9) // 제대로 찾은 폭탄인지
				find_bomb++;
			if (screen[i][j] == 11 && arr[i][j] != 9)
				miss_bomb++;
			if (screen[i][j] == 11)
				guess_bomb++;
		}
	}
	if (find_bomb == bomb && miss_bomb == 0 || crt == bomb) // 제대로 찾은 폭탄의 개수와 배치된 폭탄의 개수가 같을때 (모든 지뢰를 찾았을때) 게임을 끝냄.
	{
		whenend = clock();
		win();// 게임을 클리어했을때 실행하는 함수
	}
}
void insert_rank()
{
	FILE *rank; // *rank == 파일을 가리키는 포인터..?

	rank = fopen("C:\\Users\\user\\Desktop\\호떡C\\FindOut_mine\\rank.txt", "a");
	fprintf(rank, "\n %.1f", ((double)whenend - (double)whenstart) / 1000);
	fclose(rank);
}
//void compare_rank()
//{
//	int tmp;
//	FILE *rank = fopen("rank.txt","r");
//
//	char *pStr;
//
//	for (i = 0; i < 3; i++)
//	{
//		
//		pStr = fgets(buffer, sizeof(buffer), rank);
//		ranking = pStr;
//		//printf("%s", ranking);
//		printf("%s", pStr);
//	}
//	printf("\n\n\n\n\n\n %s \n %s", ranking);
//	
//	 fclose(rank);
//} 